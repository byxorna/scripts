#!/usr/bin/env tumblr_ruby
# stands for collins-modify
# perform actions on asset attribtues in collins easily

require 'collins_auth'
require 'yaml'
require 'optparse'

SUCCESS = "SUCCESS"
ERROR   = "ERROR"
valid_statuses = ["ALLOCATED","CANCELLED","DECOMMISSIONED","INCOMPLETE","MAINTENANCE","NEW","PROVISIONED","PROVISIONING","UNALLOCATED"]
valid_states = {
  "ALLOCATED" => ["CLAIMED","SPARE","RUNNING_UNMONITORED","UNMONITORED"],
  "MAINTENANCE" => ["AWAITING_REVIEW","HARDWARE_PROBLEM","HW_TESTING","HARDWARE_UPGRADE","IPMI_PROBLEM","MAINT_NOOP","NETWORK_PROBLEM","RELOCATION"],
  "ANY" => ["RUNNING","STARTING","STOPPING","TERMINATED"],
}

options = {
  :query_size => 9999,
  :attributes => {},
  :delete_attributes => [],
}

OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  opts.on('-a','--set-attribute attribute:value',String,"Set attribute=value. : between key and value. attribute will be uppercased.") do |x|
    a,v = x.split(':')
    options[:attributes][a.upcase.to_sym] = v
  end
  opts.on('-d','--delete-attribute attribute',String,"Delete attribute.") {|v| options[:delete_attributes] << v.to_sym }
  opts.on('-S','--set-status status[:state]',String,'Set status (and optionally state) to status:state. Requires --reason') do |v|
    status,state = v.split(':')
    options[:status] = status.upcase
    options[:state] = state.upcase unless state.nil?
  end
  opts.on('-r','--reason REASON',String,"Reason for changing status/state.") {|v| options[:reason] = v }
  opts.on('-t','--tags TAGS',Array,"Tags to work on, comma separated") {|v| options[:tags] = v.map(&:to_sym)}
  opts.on('-h','--help',"Help") {puts opts ; exit 0}
  opts.separator ""
  opts.separator "Examples:"
  opts.separator <<_EOF_
  Set an attribute on some hosts:
    #{$0} -t 001234,004567 -a my_attribute:true
  Delete an attribute on some hosts:
    #{$0} -t 001234,004567 -d my_attribute
  Delete and add attribute at same time:
    #{$0} -t 001234,004567 -a new_attr:test -d old_attr
  Set machine into maintenace noop:
    #{$0} -t 001234 -S maintenance:maint_noop -r "I do what I want"
  Set machine back to allocated:
    #{$0} -t 001234 -S allocated:running -r "Back to allocated"
  Set machine back to new without setting state:
    #{$0} -t 001234 -S new -r "Dunno why you would want this"
  Read from stdin:
    cf -n develnode | #{$0} -d my_attribute
    cf -n develnode -S allocated | #{$0} -a collectd_version:5.2.1-52
    echo -e "001234\n001235\n001236"| #{$0} -a test_attribute:'hello world'
_EOF_
end.parse!


abort "You need to tell me to do _something_, see --help" if options[:attributes].empty? and options[:delete_attributes].empty? and options[:status].nil?
abort "You need to provide a --reason when changing asset states!" if not options[:status].nil? and options[:reason].nil?

# if any statuses or states, validate them against allowed values
unless options[:status].nil?
  abort "Invalid status #{options[:status]} (Should be in #{valid_statuses.join(', ')})" unless valid_statuses.include? options[:status]
states_for_status = valid_states["ANY"].concat((valid_states[options[:status]].nil?) ? [] : valid_states[options[:status]])
  abort "State #{options[:state]} doesn't apply to status #{options[:status]} (Should be one of #{states_for_status.join(', ')})" unless options[:state].nil? or states_for_status.include?(options[:state])
end

if options[:tags].nil? or options[:tags].empty?
  # read tags from stdin. first field on the line is the tag
  input = $stdin.readlines
  options[:tags] = input.map{|l| l.split(/\s+/)[0] rescue nil}.compact.uniq
end

begin
  collins = Collins::Authenticator.setup_client
rescue => e
  abort "Unable to set up Collins client! #{e.message}"
end

exit_clean = true
options[:tags].each do |t|
  options[:attributes].each do |k,v|
    success,message = begin
      [collins.set_attribute!(t,k,v),nil]
    rescue => e
      [false,e.message]
    end
    exit_clean = success && exit_clean
    puts "#{success ? SUCCESS : ERROR}: #{t} set #{k}=#{v}#{message.nil? ? nil : " (%s)" % e.message}"
  end
  options[:delete_attributes].each do |k|
    success,message = begin
      [collins.delete_attribute!(t,k),nil]
    rescue => e
      [false,e.message]
    end
    exit_clean = success && exit_clean
    puts "#{success ? SUCCESS : ERROR}: #{t} delete #{k}#{message.nil? ? nil : " (%s)" % e.message}"
  end
  if options[:status]
    success,message = begin
      [collins.set_status!(t, :status => options[:status], :state => options[:state], :reason => options[:reason]), nil]
    rescue => e
      [false,e.message]
    end
    exit_clean = success && exit_clean
    puts "#{success ? SUCCESS : ERROR}: #{t} set status to #{options[:status]}#{options[:state] ? ":#{options[:state]}" : ''}#{message.nil? ? nil : " (%s)" % e.message}"
  end
end

exit exit_clean ? 0 : 1

