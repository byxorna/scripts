#!/usr/bin/env tumblr_ruby
# stands for collins-find
# look up hosts quickly from collins from the CLI

require 'collins_client'
require 'yaml'
require 'optparse'

options = {
  :collins_config_file => "/var/db/collins.yaml",
  :query_size => 9999,
  :separator => "\t",
  :attributes => {},            # additional attributes to query for
  :tags => [:tag, :hostname, :nodeclass, :status, :pool, :primary_role, :secondary_role],
  :timeout => 10                # default in collins_client library
}

selector_keys = [:nodeclass, :pool, :hostname, :primary_role,
                 :secondary_role, :status, :hardware_product]

OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] [hostpattern]"
  opts.on('-c','--config FILE',String,
          "Specify collins config (Default: #{options[:collins_config_file]})"
          ) {|v| options[:collins_config_file] = v}
  opts.on('-n','--nodeclass NODECLASS',String,
          "Specify a nodeclass to search for"
          ) {|v| options[:nodeclass] = v}
  opts.on('-p','--pool POOL',String,
          "Specify a pool to search for") {|v| options[:pool] = v}
  opts.on('-s','--size SIZE',Integer,
          "Number of assets to return") {|v| options[:query_size] = v}
  opts.on('-r','--role ROLE',String,"Role of machine"
          ) {|v| options[:primary_role] = v}
  opts.on('-R','--secondary-role ROLE',String,"Secondary Role of machine"
          ) {|v| options[:secondary_role] = v}
  opts.on('-H','--hardware-product PRODUCT',String,"Formal product model"
          ) {|v| options[:hardware_product] = v}
  opts.on('-S','--status STATUS',String,"Asset Status"
          ) {|v| options[:status] = v}
  opts.on('-A','--attribute attribute:value',String,"Arbitrary attributes and values to match in query. : between key and value") do |x|
    a,v = x.split(':')
    options[:attributes][a.to_sym] = v
  end
  opts.on('-T','--tag-separator TAGS',String,"Separator between tags in output") {|v| options[:attributes] = v}
  opts.on('-t','--tags TAGS',Array,"Tags to output, comma separated (Default: #{options[:tags].map(&:to_s).join(',')})"
          ) {|v| options[:tags] = v.map(&:to_sym)}
  opts.on('-a','--add-tags TAGS',Array,"Additional tags to add to output, comma separated") {|v| options[:tags].push(v.map(&:to_sym)).flatten! }
  opts.on('-x','--expire SECONDS',Integer,"Timeout in seconds (0 == forever)"
          ) {|v| options[:timeout] << v}
  opts.on('-h','--help',"Help") {puts opts ; exit 0}
end.parse!

# hostname is the final option, no flags
options[:hostname] = ARGV.shift

# if nothing passed to us, lets not search for EVERYTHING
abort "You need to query for _something_, see --help" if
  selector_keys.all? {|key| options[key].nil?} and options[:attributes].empty?

c = YAML.load_file(options[:collins_config_file]).reduce({}){|memo,(k,v)|memo[k.to_sym] = v ; memo}
c = c[:collins] if c.key? :collins
c[:host] = "https://collins.#{c[:environment]}.tumblr.net"
c[:timeout] = options[:timeout]

options[:collins_config] = c

collins = Collins::Client.new options[:collins_config]

query_opts = {
  :operation => 'AND',
  :size => options[:query_size]
}

selector_keys.each {|key|
  query_opts[key] = options[key] if options[key]
}
# now populate any other attributes
query_opts.merge!(options[:attributes])


assets = collins.find(query_opts)
if assets.length > 0
  assets.each {|a| puts options[:tags].map {|t|
      if t == "state"
        a.send(t).label
      else
        a.send(t)
      end
    }.join(options[:separator])
  }
else
  $stderr.puts "No assets found"
  exit 1
end

