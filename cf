#!/usr/bin/env tumblr_ruby
# stands for collins-find
# look up hosts quickly from collins from the CLI

require 'collins_auth'
require 'yaml'
require 'optparse'

options = {
  :query_size => 9999,
  :separator => "\t",
  :attributes => {},            # additional attributes to query for
  :columns => [:tag, :hostname, :nodeclass, :status, :pool, :primary_role, :secondary_role],
  :timeout => 10                # default in collins_client library
}

selector_keys = [:nodeclass, :pool, :hostname, :primary_role, :secondary_role, :status, :hardware_product, :tag]

OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] [hostnamepattern]"
  opts.separator "Query options:"
  opts.on('-t','--tag TAG',String, "Assets with tag TAG") {|v| options[:tag] = v}
  opts.on('-n','--nodeclass NODECLASS',String, "Assets in nodeclass NODECLASS") {|v| options[:nodeclass] = v}
  opts.on('-p','--pool POOL',String, "Assets in pool POOL") {|v| options[:pool] = v}
  opts.on('-s','--size SIZE',Integer, "Number of assets to return") {|v| options[:query_size] = v}
  opts.on('-r','--role ROLE',String,"Assets in primary role ROLE") {|v| options[:primary_role] = v}
  opts.on('-R','--secondary-role ROLE',String,"Assets in secondary role ROLE") {|v| options[:secondary_role] = v}
  opts.on('-H','--hardware-product PRODUCT',String,"Assets with formal product model PRODUCT") {|v| options[:hardware_product] = v}
  opts.on('-S','--status STATUS',String,"Asset Status") {|v| options[:status] = v}
  opts.on('-a','--attribute attribute:value',String,"Arbitrary attributes and values to match in query. : between key and value") do |x|
    a,v = x.split(':')
    options[:attributes][a.to_sym] = v
  end
  opts.separator "Formatting/extra options:"
  opts.on('-c','--columns ATTRIBUTES',Array,"Attributes to output as columns, comma separated (Default: #{options[:columns].map(&:to_s).join(',')})") {|v| options[:columns] = v.map(&:to_sym)}
  opts.on('-x','--extra-columns ATTRIBUTES',Array,"Additional attributes to add to output as columns, comma separated") {|v| options[:columns].push(v.map(&:to_sym)).flatten! }
  opts.on('-f','--field-separator SEPARATOR',String,"Separator between columns in output (Default: #{options[:separator]})") {|v| options[:separator] = v}
  opts.on('--expire SECONDS',Integer,"Timeout in seconds (0 == forever)") {|v| options[:timeout] = v}
  opts.on('-h','--help',"Help") {puts opts ; exit 0}

  opts.separator <<_EXAMPLES_
Examples:
    Query for devnodes in DEVEL pool that are VMs
      cf -n develnode -p DEVEL
    Query for asset 001234, and show its system_password
      cf -t 001234 -x system_password
    Query for all decommissioned VM assets
      cf -a is_vm:true -S decommissioned
    Query for hosts matching hostname 'web6-'
      cf web6-
_EXAMPLES_
end.parse!

# hostname is the final option, no flags
options[:hostname] = ARGV.shift

# if nothing passed to us, lets not search for EVERYTHING
abort "You need to query for _something_, see --help" if
  selector_keys.all? {|key| options[key].nil?} and options[:attributes].empty?

begin
  collins = Collins::Authenticator.setup_client timeout: options[:timeout]
rescue => e
  abort "Unable to set up Collins client! #{e.message}"
end

query_opts = {
  :operation => 'AND',
  :size => options[:query_size]
}

selector_keys.each {|key|
  query_opts[key] = options[key] if options[key]
}
# now populate any other attributes
query_opts.merge!(options[:attributes])


begin
  assets = collins.find(query_opts)
  if assets.length > 0
    assets.each do |a|
      puts options[:columns].map do |t|
        (t == :state) ?  a.send(t).label : a.send(t)
      end.join(options[:separator])
    end
  else
    abort "No assets found"
  end
rescue => e
  abort "Error querying collins: #{e.message}"
end

